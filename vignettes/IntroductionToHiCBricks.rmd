---
title: "Introduction To HiCBricks"
author:
- name: Koustav Pal
  affiliation: 
    - IFOM - FIRC Institute of Molecular Oncology, Milan, Italy
- name: Carmen Maria Livi
  affiliation: IFOM - FIRC Institute of Molecular Oncology, Milan, Italy
output: 
  BiocStyle::html_document:
    toc_float: true
    css: custom.css
  BiocStyle::pdf_document: default
package: HiCBricks
abstract: |
  HiCBricks offers user-friendly and efficient solutions for handling large 
  high-resolution Hi-C datasets. The package provides a R/Bioconductor 
  framework with the bricks to build more complex data analysis pipelines 
  and algorithms.
vignette: |
  %\VignetteIndexEntry{Introduction To HiCBricks}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---



> **Note by the developer**
> HiCBricks is currently in version 1.0. If users find some features to be missing, experience any issue with the package or find any problems in its usage please do open an issue on the [github page](https://github.com/koustav-pal/HiCBricks).


# Introduction

HiCBricks is a library designed for handling large high-resolution Hi-C datasets. Over the years, the Hi-C field has experienced a rapid increase in the size and complexity of datasets. HiCBricks is meant to overcome the challenges related to the analysis of such large datasets within the R environment.

HiCBricks leverages HDF (Hierarchical Data Format) files to allow efficient handling of large Hi-C contact matrices. HiCBricks implements a Hi-C specific HDF data structure, referred to as a _Brick object_ and presents accessor functions allowing users to access and manipulate Hi-C data without all the difficultis of dealing with the complex structure of HDF files.

The HiCBricks package, its set of data retrieval functions along with the _Brick objects_ are meant to serve as building blocks for custom Hi-C analysis procedures as well as the development of new R or Bioconductor packages.


# Create Brick objects to store Hi-C data

HiCBricks uses HDF files to efficiently manage large Hi-C datasets. Hereafter, we refer to the structured data contained into HiCBricks HDF files as _Brick objects_. The _Brick object_ implement a HDF structure consisting of three layers:

1. The Hi-C contact matrix, defined as a complete 2D matrix for each chromosome and chromosome-pair. The contact matrix for the _cis_ (intra-chromosomal) contacts for each chromosome is square `n x n` dimensional matrix. On the other hand, the _trans_ (inter-chromosomal) contacts for each chromosome pair is a rectangular `n x m` dimensional matrix.
2. The bin table, defined as the set of genomic positions intervals/ranges (chromosome, start, end) associated to each row or column of the contact matrix. This can be defined as eithed fixed size bins or variable size bins. The latter may be useful for example to handle very high-resolution Hi-C contacts at single restriction fragment resolution.
3. Annotations (optional) that the end-user may want to associate to the Hi-C data. This information may be, but is not limited to, TAD calls, Peak calls, RNA-seq expression data. In principle, if the annotation information can be represented as a `GenomicRanges` object, it can be stored in the _Brick object_.
 
In order to load Hi-C data matrix into a _Brick object_ we have to:

1.  create HDF file with HiCBricks specific data structure
2.  populate the HDF data structure with Hi-C data

The key advantage of HDF files is that once they have been created and populated with data, the data can be accessed very efficiently without the need to reload the whole matrix into memory each time.

Currently, HiCBricks functionalities allows importing data from text files with complete 2D matrices and binary cooler files (_.mcool_ or _.cool_).

## Creating a Brick object from a text file 2D contact matrix

> All files in this vignette will be created in a temporary directory, the location of which is available through `tempdir()`. Any files stored in this temporary directory will be deleted upon closure of the R session. Users are therefore advised to peruse the code before execution and to replace `tempdir()` with their own project directory locations when working with their own datasets. 

First of all load the HiCBricks library:

```{r, message = FALSE}
library("HiCBricks")

```

Then get the path to the test datasets provided with the package, and in particular the path to the “bin table” specifying the genomics coordinates associated to each genomic bin used to summarize the Hi-C data. These would correspond to row and columns of the Hi-C contact matrix. In this example the `bin table` provided is for human chromosome 19 divided in equally sized bins of 40 Kb.

```{r}

Bintable.path <- system.file("extdata",
"Bintable_40kb.txt", package = "HiCBricks")
Chromosomes <- "chr19"

```

Then, the backbone of the _Brick object_ data structure is created using only the bin table. The actual contacts frequencies will be added later. The `CreateBrick` function returns a named character vector containing the complete path to the HDF file that will store the data. 


```{r}

Path_to_cached_file <- CreateBrick(ChromNames = Chromosomes,
    BinTable = Bintable.path, bin.delim = " ",
    Output.Filename = file.path(tempdir(),"test.hdf"), exec = "cat",
remove.existing = TRUE)

```


> **Technical note**
This code chunk is the first place users will encounter the `exec` parameter. The `exec` argument is incredibly powerful as it allows users to provide any number of ways to first manipulate and then read the bin table file. Using `exec`, the file to be read is first processed and then read through one of many traditional system utility functions. The `exec` parameter takes `cat` as the default value. This corresponds to the system utility `cat` used for reading text files. Similarly, if the file is compressed, the `exec` parameter can take as values popular compression utilities `zcat` or `bzcat` for reading the compressed file. 
For advanced users, the `exec` parameter can contain full length `awk` or `cut` commands to sort and filter out columns or rows which are not required from the file. Thus, rather than read the same file twice using two different programs, users can provide a system command which will process the file and then pipe the processed output to the R session.

As an illustrative example, to clarify the expected structure of input data for a complete 2D matrix in text format, we are generating a fake contact matrix, containing pairwise distances between the genomic bins of the bin table, then loading these as if they were contact data.

First we create an empty `n x n matrix (with n=800)`.

```{r}

Test.mat <- matrix(NA,nrow = 800, ncol = 800)

```

Then we replace the matrix content with pairwise distances between genomic bins 

```{r}

Row <- row(Test.mat)
Col <- col(Test.mat)
Dist <- Col - Row

```

Finally the matrix is written to a txt file, without headers or rownames, and using whitespace as the field delimiter in this example.


```{r}

Matrix.file <- file.path(tempdir(),"Test_matrix.txt")
write.table(x = Dist, file = Matrix.file, sep = " ", quote = FALSE,
row.names = FALSE, col.names = FALSE)

```

We are now ready to load the 2D matrix data from the `Matrix.file` into the _Brick object_. When doing so, we have to pass to the `Brick_load_matrix` function the path to the HDF file (so far containing only the bin table). Then we have to specify which chromosome (for intra-chromosomal _n x n_ contact matrix) or which pair of chromosomes (for inter-chromosomal _n x m_ contact matrix) are contained in the `matrix.file`. In case of intra-chromosomal contacts like in this example, `chr1` and `chr2` arguments will have the same value.


```{r}

Brick.file <- Path_to_cached_file

Brick_load_matrix(Brick = Brick.file,
    chr1 = "chr19",
    chr2 = "chr19",
    matrix.file = Matrix.file,
    delim = " ",
    exec = "cat",
    remove.prior = TRUE)

```

If you have a very large 2D _cis_ matrix, you may want to load data till a certain distance from the diagonal, as the contact frequency is rapidly decaying with distance, thus a you may find a very sparse matrix at longer distances.

In this example we load up to 100 diagonals:

```{r}

Brick_load_cis_matrix_till_distance(Brick = Brick.file,
    chr = "chr19",
    matrix.file = Matrix.file,
    delim = " ",
    distance = 100,
    remove.prior = TRUE)

```

## Creating Brick objects from .mcool binary files

HiCBricks functions allow HDF files with the _mcool_ or _cool_ formats to be converted into HDF files with the _Brick_ format. _mcool_, is a standard data format designed by the [4D nucleome project](https://www.4dnucleome.org/) and facilitates the storage of very large experiments within a single HDF file. These files contain Hi-C contact matrices in the sparse format. In this case, _mcool_ and _cool_ files store the non-zero upper-triangle values in the HDF file across multiple normalisations and resolutions. HiCBricks, on the other hand stores a single normalisation and single resolution in any given HDF file.

In this exercise we will download a file from the 4DN data portal at https://data.4dnucleome.org/. For the purposes of this vignette we will use a randomly chosen H1-hESC Hi-C data.

Please note, that these are very large files, and require a lot of time to download.

You can download it using curl.

```{r eval = FALSE}
require(curl)
Consortium.home = "https://data.4dnucleome.org/files-processed"
File = file.path(Consortium.home,"4DNFI7JNCNFB",
    "@@download","4DNFI7JNCNFB.mcool")
curl_download(url = File,
    destfile = "./H1-hESC-HiC-4DNFI7JNCNFB.mcool")

```

This contains normalised Hi-C data on H1-hESC cells using the DpnII enzyme. Note that there are a few normalisation weights available within the sample. We can check what normalisation weights are available using `Brick_list_mcool_normalisations`. Please note, that this function does not list the normalisation weights available within the mcool file, but rather lists normalisation factors that HiCBricks accepts from the mcool files. Notice, the human readable names and the actual dataset names, what you are interested in are the human readable names, which makes the type of normalisation apparent. Such as for example, KR is an abbreviation for the Knight Ruitz matrix balancing algorithm introduced by Rao et al., 2014^[A 3D map of the human genome at kilobase resolution reveals principles 
of chromatin looping.
Rao SS, Huntley MH, Durand NC, Stamenova EK, Bochkov ID, Robinson JT, Sanborn AL, Machol I, Omer AD, Lander ES and Aiden EL. Cell, 2014].

```{r eval = FALSE}

Brick_list_mcool_normalisations(names.only = TRUE)

## [1] "Knight-Ruitz"                 "Vanilla-coverage"
## [3] "Vanilla-coverage-square-root" "Iterative-Correction"

```

This lists only the human-readable names. To see both the abbreviation and the
base column name, 

```{r eval = FALSE}

Brick_list_mcool_normalisations()

```
will list all names including their linked columns in the HDF file. 

The 4D nucleome project bins their data into several different resolutions, `Brick_list_mcool_resolutions` can help users to check what resolutions are available within the _mcool_ file. This function provides information regarding the different resolutions present within the _mcool_ files themselves.

```{r eval = FALSE}

mcoolName="H1-hESC-HiC-4DNFI7JNCNFB.mcool"
Brick_list_mcool_resolutions(mcool = mcoolName)

```

Using the information on the resolutions present within the _mcool_ file and the normalisation factors accepted by HiCBricks, users can query the _mcool_ files to find out if a given normalisation factor is present for a given resolution.

```{r eval = FALSE}

Brick_mcool_normalisation_exists(mcool = mcoolName, 
    norm.factor = "Iterative-Correction",
    binsize = 10000)

```

HiCBricks allows users to create HDF files with the _Brick_ format from _mcool_ and _cool_ files. Users are limited to a single resolution and normalisation factor per _Brick object_. When creating a _Brick object_ users are able to load all chromosomes in a single Brick object, but I do not recommend this because, 

- It is not possible for multiple processes to concurrently access the same HDF file. Therefore, it hinders parallelization.
- The presence of multiple matrices in the same file, results in an increase in read and write speeds.

Instead when using high-resolution Hi-C contact matrices, I encourage users to separate the matrices chromosome by chromosome into different brick objects.

Similar to the previous section, we will:

1. Create a _Brick object_ containing the HiCBricks data structure
2. populate this HDF data structure with Hi-C data

Previously, users used the `CreateBrick` function to create _Brick objects_ for 2D matrices. To create _Brick objects_ from _mcool_ files we will use the `CreateBrick_from_mcool` function. 

When creating _Brick objects_ from scratch users were required to provide a bin table. For _mcool_ files users do not need to provide a bin table as the bin table information is already embedded within the _mcool_ files. Therefore, users can provide the resolution they want to load, and the binning information will be fetched from the _mcool_ files.

Using the `chrs` param users can limit the structure created to the relevant chromosomes or if left NULL, will create the structure for all chromosome pairs. Please note, that if the length of chrs is 2, 4 interaction maps will be created.
Two for the `cis` (intra-chromosomal) interaction maps for each chromosome and two for the `trans` (inter-chromosomal) interaction maps corresponding to each chromosome pair. 

```{r eval = FALSE}

Brick.name <- "H1-hESC-HiC-4DNFI7JNCNFB-10000-ICE-normalised-chr1.brick"

Output.brick <- CreateBrick_from_mcool(Brick = Brick.name, 
    mcool = mcoolName, binsize = 10000, chrs = "chr1", remove.existing = TRUE)

```

After the _Brick object_ has been created, we will populate the HDF file with values coming from the Hi-C interaction matrix stored within the _mcool_ file. For this, we use the `Brick_load_data_from_mcool` function.

```{r eval = FALSE}

Brick_load_data_from_mcool(Brick = Output.brick,
    mcool = mcoolName,
    chr1 = "chr1",
    chr2 = "chr1",
    binsize = 10000,
    cooler.batch.size = 1000000,
    matrix.chunk = 2000,
    dont.look.for.chr2 = TRUE,
    remove.prior = TRUE,
    norm.factor = "Iterative-Correction")

```

There are a few options allowing users to manipulate data read and write speeds. `cooler.batch.size` determines the number of records read per iteration through an _mcool_ file. `matrix.chunk` determines the size of the matrix square that will be loaded per iteration through an _mcool_ file. If you are loading *cis* matrices, it is recommended to set the `dont.look.for.chr2` parameter to TRUE, as the first read records for chr1 will always correspond to those originating from chr2. In cases of *trans* matrices, this option should be set to FALSE allowing the function to locate the first occurence of a chr1 vs chr2 interaction. `remove.prior` defaults to FALSE and prevents users from loading datasets twice.

## Creating Brick objects from .hic binary files

The method to create a Brick object from a `.hic` file is still a work in progress and will be a part of the package in a future release. Meanwhile, if users wish to create a `.hic` file into a _Brick object_, they should first use the `hic2cool` utility to create an `mcool` file and then read that `mcool` file into a _Brick object_. This utility is available at 4D nucleome [github repository](https://github.com/4dn-dcic/hic2cool).

# Accessing data in Brick objects

There are three different types of information which are currently stored within _Brick objects_.

1. The first, is the Hi-C interaction maps for each chromosome and chromosome-pair.
2. The second are fixed width or variable width genomic coordinates laid out as `GenomicRanges` objects that maps the rows and columns of each Hi-C interaction matrix to their corresponding genomic coordinates.
3. The last is the custom annotations that a user may want to associate with a _Brick object_ laid out as a `GenomicRanges` object. 

Therefore, there are accessor functions related to the contact matrix, and to the `GenomicRanges` that are stored in the HiCBricks object. Within these accessor functions, there are the _list_, _fetch_ and _get_ methods.

## Working with genomic coordinates in a brick object

We refer to genomic coordinates as _ranges_ objects, since all genomic coordinate output from HiCBricks comes in the form of `GenomicRanges` objects. `GenomicRanges` is the de-facto standard for working with genomic coordinates in the R/Bioconductor environment. 

As mentioned in the introduction to this section, HiCBricks objects contain two different types of `ranges` objects. The first is the bin table, which is central towards the proper functioning of HiCBricks functions, and is mostly inaccessible for user modifications. The second are annotation for the user's reference and is completely accessible for the user.


## Accessing ranges objects in a brick store

Each of the _ranges objects_ are stored under a unique id. The bin table always holds the id, "Bintable" whereas other _ranges objects_ can hold other unique identifiers as per the user's purview. As mentioned before, users can *list* attributes of a Brick object and they can *fetch* the same objects. 

Therefore, we can first *list* the unique identifiers of each of the _ranges_ that are stored in the HDF file. 

```{r}

Brick.file <- system.file("extdata", "test.hdf", package = "HiCBricks")

Brick_list_rangekeys(Brick.file)

```

This lists the available rangekeys in the test _Brick object_. There are two _ranges_ that are listed. The first, is the bin table, whereas the second is an example custom annotations that I had stored in the HDF file after creating it.  

If we want to retrieve the bin table, we can *fetch/get* the bin table.

```{r}

Brick_get_bintable(Brick.file)

```

Otherwise, you can retrieve the object using `Brick_get_ranges` the method called by `Brick_get_bintable`.

```{r}

Brick_get_ranges(Brick = Brick.file,
    rangekey = "Bintable")

```

While fetching the ranges object we can also subset the retrieved ranges by the chromosome of interest.

```{r}

Brick_get_ranges(Brick = Brick.file,
    rangekey = "Bintable",
    chr = "chr19")

```

### Identifying matrix row/col using ranges operations

Users may sometimes find it useful to identify the corresponding matrix row/col for a particular coordinate.

```{r}

Brick_return_region_position(Brick = Brick.file,
    region = "chr19:5000000:10000000")


```

This does a **within** overlap operation and returns the corresponding coordinates. Therefore, sometimes when the region of interest is smaller than the ranges corresponding to the particular matrix region of interest, this function may fail.

To have more fine-grain control, users may choose to use `Brick_fetch_range_index` which is called by `Brick_return_region_position`.

```{r}

Brick_fetch_range_index(Brick = Brick.file,
    chr = "chr19",
    start = 5000000,
    end = 10000000)


```

This function will return a GRanges object containing one row for each element in the provided *chr,start,end* vectors, with a `NumericList` column "Indexes" corresponding to the overlapping row/col coordinate of that matrix.

## Accessing matrices in a brick store

There are three ways to subset matrices.

- By distance
- Selecting sub-matrices
- Selecting rows or columns

### Retrieving points separated by a certain distance

It is possible to get the interactions between genomic loci separated by a certain distance.

```{r}

Values <- Brick_get_values_by_distance(Brick = Brick.file,
    chr = "chr19",
    distance = 4)

```

Users can also choose to transform it during retrieval

```{r}

Failsafe_median_log10 <- function(x){
    x[is.na(x) | is.nan(x) | is.infinite(x)] <- 0
    return(median(log10(x+1)))
}


Brick_get_values_by_distance(Brick = Brick.file,
    chr = "chr19",
    distance = 4,
    FUN = Failsafe_median_log10)

```

They can even subset the values by a certain region of interest, such as TADs by using the `constrain.region` function. Notice, how we can provide human readable coordinate information to this particular parameter. HiCBricks, explicitly requires the delimiter of the coordinates to always be ":".


```{r}

Failsafe_median_log10 <- function(x){
    x[is.na(x) | is.nan(x) | is.infinite(x)] <- 0
    return(median(log10(x+1)))
}

Brick_get_values_by_distance(Brick = Brick.file,
    chr = "chr19",
    distance = 4,
    constrain.region = "chr19:1:5000000",
    FUN = Failsafe_median_log10)

```

### Retrieving subsets of a matrix

HiCBricks, implements retrieval of sub-matrices in coordinate like manned. That means, you can retrieve data in an almost word like fashion. Once again, we ask users to make note of the human readable coordinate format in the `x.coords` and `y.coords` parameters.

```{r}

Sub.matrix <- Brick_get_matrix_within_coords(Brick = Brick.file,
    x.coords="chr19:5000000:10000000",
    force = TRUE,
    y.coords = "chr19:5000000:10000000")

```

Users may think, but it is not the same as getting the sub-matrix yourself.

```{r}

x.axis <- 5000000/40000
y.axis <- 10000000/40000

Sub.matrix <- Brick_get_matrix(Brick = Brick.file,
    chr1 = "chr19", chr2 = "chr19",
    x.vector = c(x.axis:y.axis),
    y.vector = c(x.axis:y.axis))

```

Notice, that this selection has one more row and column. This is because the region of interest spans from **5000001:10000000**, which starts from the `x.axis + 1` and not from `x.axis`. 

Finally, it is also possible to fetch entire rows and columns. Users can do so either with names, which correspond to names of the matrix rows/cols from the bintable in the coordinate format specific earlier, i.e. `chr:start:end`. If these are names, it is required to specify `by = "ranges"`.

```{r}

Coordinate <- c("chr19:1:40000","chr19:40001:80000")
Brick.file <- system.file("extdata",
    "test.hdf",
    package = "HiCBricks")
Test_Run <- Brick_fetch_row_vector(Brick = Brick.file,
    chr1 = "chr19",
    chr2 = "chr19",
    by = "ranges",
    vector = Coordinate,
    regions = c("chr19:1:1000000", "chr19:40001:2000000"))

```

Users can also choose to fetch data `by = positions`.

```{r}

Coordinate <- c(1,2)
Brick.file <- system.file("extdata",
    "test.hdf",
    package = "HiCBricks")
Test_Run <- Brick_fetch_row_vector(Brick = Brick.file,
    chr1 = "chr19",
    chr2 = "chr19",
    by = "position",
    vector = Coordinate,
    regions = c("chr19:1:1000000", "chr19:40001:2000000"))

```

If regions is provided, it will subset the corresponding row/col by the specified region. `regions` must be in coordinate format as shown below.

### Accessing matrix metadata columns

There are several metrics which are computed at the time of matrix load. Principally,
- **bin.coverage** quantifies the proportion of non-zero rows/cols
- **row.sums** quantifies the total signal value of any row
- **sparsity** quantifies the proportion of non-zero values at a certain distance from the diagonal

Sparsity is only quantified if a matrix is defined as sparse during matrix load.

Users can check the names of the various matrix metadata columns.

```{r}

Brick_list_matrix_mcols()

```

And then fetch one such metadata column

```{r}

Brick.file <- system.file("extdata",
    "test.hdf",
    package = "HiCBricks")
MCols.dat <- Brick_get_matrix_mcols(Brick = Brick.file,
    chr1 = "chr19",
    chr2 = "chr19",
    what = "row.sums")
head(MCols.dat, 100)

```

### Matrix utility functions

There are several utility functions that a user may take advantage of to do various checks.

- Check if a matrix has been loaded into the Brick store

```{r}

Brick_matrix_isdone(Brick = Brick.file,
    chr1 = "chr19",
    chr2 = "chr19")

```

- Check if a matrix was defined as a sparse matrix

```{r}

Brick_matrix_issparse(Brick = Brick.file,
    chr1 = "chr19",
    chr2 = "chr19")

```

- Check the maximum distance until which a matrix was loaded. This particular function is relevant only when the `Brick_load_cis_matrix_till_distance` has been used.

```{r}

Brick_matrix_maxdist(Brick = Brick.file,
    chr1 = "chr19",
    chr2 = "chr19")

```

- Check if a matrix was defined for a particular chromosome pair

```{r}

Brick_matrix_exists(Brick = Brick.file,
    chr1 = "chr19",
    chr2 = "chr19")

```

- Check the minimum and maximum values present within the matrix

```{r}

Brick_matrix_minmax(Brick = Brick.file,
    chr1 = "chr19",
    chr2 = "chr19")

```

- Get the matrix dimensions, irrespective of the maxdist value.

```{r}

Brick_matrix_dimensions(Brick = Brick.file,
    chr1 = "chr19",
    chr2 = "chr19")

```

- Get the original filename of a loaded matrix

```{r}

Brick_matrix_filename(Brick = Brick.file,
    chr1 = "chr19",
    chr2 = "chr19")

```

# Example analyses implemented in HiCBricks 

## Call Topologically Associated Domains with Local score differentiator (LSD)

Local score differentiator (LSD) is a TAD calling procedure based on the
directionality index introduced by Dixon et al., 2012^[Topological domains in 
mammalian genomes identified by analysis of chromatin interactions.
Dixon JR, Selvaraj S, Yue F, Kim A, Li Y, Shen Y, Hu M, Liu JS and Ren B.
Nature 2012]. LSD is based on the computation of the directionality index 
(DI), as described in the original article, but the genome is partitioned 
into TADs based on the local directionality index distribution. Briefly, 
transition points between negative and positive values marking TAD boundaries 
are identified as the local extreme values in the first derivative of DI 
computed within a local window of user defined size. We first introduced 
this procedure with our study (Pal et al., in revision). This has been 
adapted to work with HiCBricks to show how different analysis procedures 
can take advantage of the HiCBricks accessor functions.

```{r}
Brick.file <- system.file("extdata",
    "test.hdf", package = "HiCBricks")

Chromosome <- "chr19"
di_window <- 10
lookup_window <- 30
TAD_ranges <- Brick_local_score_differentiator(Brick = Brick.file,
    chrs = Chromosome,
    di.window = di_window,
    lookup.window = lookup_window,
    strict = TRUE,
    fill.gaps=TRUE,
    chunk.size = 500)
```

`lookup.window` value corresponds to the local window used to subset the directionality index distribution. Setting `strict` to TRUE, adds another additional filter wherein the directionality index is required to be less than or greater than 0 at potential change points identifying a domain boundary. LSD works by identifying domain starts and ends, if a particular domain start was not identified, but the adjacent domain end was identified, `fill.gaps` if set to TRUE, will infer the adjacent bin from the adjacent domain end as a domain start bin and create a domain. Any domains identified by `fill.gaps` are annotated under the *level* column in the resulting GRanges object with the value 2. `chunk.size` corresponds to the size of the square to retrieve and process per iteration. 

As shown previously, we can store these TAD calls along with the _Brick object_.

```{r}

Name <- paste("LSD",
    di_window,
    lookup_window,
    Chromosome,sep = "_")
Brick_add_ranges(Brick = Path_to_cached_file,
    ranges = TAD_ranges,
    rangekey = Name)

```

### Fetching the TAD calls from the Brick object

As shown previously, we can list the unique identifiers of the stored ranges (_rangekeys_) using the `Brick_list_rangekeys` function and then retrieve them using the `Brick_get_ranges` function.

```{r}

Brick_list_rangekeys(Brick = Path_to_cached_file)

TAD_ranges <- Brick_get_ranges(Brick = Path_to_cached_file,
    rangekey = Name)

```

## Creating pretty heatmaps using HiCBricks

Using HiCBricks functions, users can plot pretty Hi-C heatmaps. HiCBricks allows users to plot one sample or two sample heatmaps. This lists the most basic commands required to generate a heatmap.

### Plotting one sample heatmaps

```{r plot, fig.cap = "A normal heatmap without any transformations", fig.small = TRUE}

Brick_vizart_plot_heatmap(File = file.path(tempdir(), 
  "chr19-5MB-10MB-normal.pdf"),
    Bricks = Brick.file,
    x.coords = "chr19:5000000:10000000",
    y.coords = "chr19:5000001:10000000",
    palette = "Reds",
    width = 10,
    height = 11,
    return.object=TRUE)

```

Notice the **palette** argument. It requires the user to provide a palette name
from either the *RColorBrewer* or *viridis* colour palettes. It is not possible
at this time to provide user defined colour palettes. 

Since we are directly plotting the Hi-C signal, the colours may seem a bit
muted. We should go ahead and change that with a *log10* transformation,
which will squeeze the signal distribution and make it pretty.

```{r plot2, fig.cap = "A normal heatmap with colours computed in log10 scale", fig.small = TRUE}

Failsafe_log10 <- function(x){
    x[is.na(x) | is.nan(x) | is.infinite(x)] <- 0
    return(log10(x+1))
}

Brick_vizart_plot_heatmap(File = file.path(tempdir(), 
  "chr19-5MB-10MB-normal-colours-log10.pdf"),
    Bricks = Brick.file,
    x.coords = "chr19:5000000:10000000",
    y.coords = "chr19:5000001:10000000",
    FUN = Failsafe_log10,
    legend.title = "Log10 Hi-C signal",
    palette = "Reds",
    width = 10,
    height = 11,
    return.object=TRUE)

```

Notice, how we created a new function for log10 transformation. This function
and others like it can be provided with the argument *FUN*. 

This is an already much more dense heatmap. 

Sometimes, the Hi-C signal distribution is biased by extreme values which tends
to blow up the entire distribution in a heatmap plot. We can pull in these
values to create a more uniform and prettier picture, with the *value.cap*
argument.

```{r plot3, fig.cap = "A normal heatmap with colours computed in log10 scale after capping values to the 99th percentile", fig.small = TRUE}

Brick_vizart_plot_heatmap(File = file.path(tempdir(),
  "chr19-5MB-10MB-normal-colours-log10-valuecap-99.pdf"),
    Bricks = Brick.file,
    x.coords = "chr19:5000000:10000000",
    y.coords = "chr19:5000001:10000000",
    FUN = Failsafe_log10,
    value.cap = 0.99,
    legend.title = "Log10 Hi-C signal",
    palette = "Reds",
    width = 10,
    height = 11,
    return.object=TRUE)

```

*value.cap* takes as input a value ranging from 0,1 identifying the quantile at
which the threshold will be applied. Also note, how the presence of this
argument triggers presence of the greater than or less than sign.


Sometimes, it is desirable to plot the heatmap as a rotated heatmap.


```{r plot4, fig.cap = "Same heatmap as before with colours computed in log10 scale after capping values to the 99th percentile with 45 degree rotation", fig.small = TRUE}

Brick_vizart_plot_heatmap(File = file.path(tempdir(),
  "chr19-5MB-10MB-normal-colours-log10-rotate.pdf"),
    Bricks = Brick.file,
    x.coords = "chr19:5000000:10000000",
    y.coords = "chr19:5000001:10000000",
    FUN = Failsafe_log10,
    value.cap = 0.99,
    distance = 60,
    legend.title = "Log10 Hi-C signal",
    palette = "Reds",
    width = 10,
    height = 11,
    rotate = TRUE,
    return.object=TRUE)

```

But this looks ugly. To fix it we need to modify the `width` and `height` as
the rotated plots are broader than they are taller.

```{r plot5, fig.cap = "Same heatmap as previous, but now the heatmaps are wider than they are taller", fig.wide = TRUE}

Brick_vizart_plot_heatmap(File = file.path(tempdir(),
  "chr19-5MB-10MB-normal-colours-log10-rotate-2.pdf"),
    Bricks = Brick.file,
    x.coords = "chr19:5000000:10000000",
    y.coords = "chr19:5000001:10000000",
    FUN = Failsafe_log10,
    value.cap = 0.99,
    distance = 60,
    legend.title = "Log10 Hi-C signal",
    palette = "Reds",
    width = 15,
    height = 5,
    rotate = TRUE,
    return.object=TRUE)

```

We can now also plot the TADs on these plots.

```{r plot6, fig.cap = "Normal rectangular heatmap with colours computed in the log scale after capping values to the 99th percentile with TAD calls", fig.small = TRUE}

Brick_vizart_plot_heatmap(File = file.path(tempdir(),
  "chr19-5MB-10MB-normal-colours-log10-rotate-2-tads.pdf"),
    Bricks = Brick.file,
    tad.ranges = TAD_ranges,
    x.coords = "chr19:5000000:10000000",
    y.coords = "chr19:5000001:10000000",
    colours = "#230C0F",
    FUN = Failsafe_log10,
    value.cap = 0.99,
    legend.title = "Log10 Hi-C signal",
    palette = "Reds",
    width = 10,
    height = 11,
    return.object=TRUE)
```
Notice, that using the distance parameter we can control the diagonal until
which we plot the heatmap.

```{r plot7, fig.cap = "Normal rotated heatmap with colours computed in the log scale after capping values to the 99th percentile with TAD calls", fig.wide = TRUE}
Brick_vizart_plot_heatmap(File = file.path(tempdir(),
  "chr19-5MB-10MB-normal-colours-log10-rotate-3-tads.pdf"),
    Bricks = Brick.file,
    tad.ranges = TAD_ranges,
    x.coords = "chr19:5000000:10000000",
    y.coords = "chr19:5000001:10000000",
    colours = "#230C0F",
    FUN = Failsafe_log10,
    value.cap = 0.99,
    distance = 60,
    legend.title = "Log10 Hi-C signal",
    palette = "Reds",
    width = 15,
    height = 5,
    line.width = 0.8,
    cut.corners = TRUE,
    rotate = TRUE,
    return.object=TRUE)
```

### Plotting bipartite (two-sample) heatmaps

HiCBricks makes it possible to plot bipartite or two sample heatmaps. 
Bipartite heatmaps can be plotted as square maps or as rotated maps with or 
without TADs. Due to space limitations placed on example datasets, we will 
use the same dataset as before to showcase how two-sample heatmaps can be 
made using the HiCBricks package. 

To plot a two sample heatmap, we need only include an additional Brick file in
the `Brick` parameter. 

*NOTE:* The main diagonal will be set to the minimum value in both plots.

```{r plot8, fig.cap = "A normal two sample heatmap with colours computed in log10 scale after capping values to the 99th percentile", fig.small = TRUE}

Brick_vizart_plot_heatmap(File = file.path(tempdir(),
  "chr19-5MB-10MB-bipartite-colours-log10-valuecap-99.pdf"),
    Bricks = c(Brick.file, Brick.file),
    x.coords = "chr19:5000000:10000000",
    y.coords = "chr19:5000001:10000000",
    FUN = Failsafe_log10,
    value.cap = 0.99,
    legend.title = "Log10 Hi-C signal",
    palette = "YlGnBu",
    width = 10,
    height = 11,
    return.object=TRUE)

```

Since this Hi-C map is sparse, we can go ahead and remove distant interactions.
This is achieved using the `distance` parameter. Remember, that we can use any
of the `RColorBrewer` or `viridis` colour palettes. For example, we can use
the Red to Gray (name RdGy) palette from `RColorBrewer`


```{r plot9, fig.cap = "A normal two sample heatmap with colours computed in log10 scale on values until the 30th diagonal and capping these values to the 99th percentile.", fig.small = TRUE}

Brick_vizart_plot_heatmap(File = file.path(tempdir(),
  "chr19-5MB-10MB-bipartite-colours-log10-valuecap-99-2.pdf"),
    Bricks = c(Brick.file, Brick.file),
    x.coords = "chr19:5000000:10000000",
    y.coords = "chr19:5000001:10000000",
    FUN = Failsafe_log10,
    value.cap = 0.99,
    legend.title = "Log10 Hi-C signal",
    palette = "RdGy",
    distance = 30,
    width = 10,
    height = 11,
    return.object=TRUE)

```

Finally, we can once again rotate the two sample heatmaps.

```{r plot10, fig.cap = "A rotated two sample heatmap with colours computed in log10 scale and capping these values to the 99th percentile.", fig.wide = TRUE}

Brick_vizart_plot_heatmap(File = file.path(tempdir(),
  "chr19-5MB-10MB-bipartite-colours-log10-valuecap-99-rotate.pdf"),
    Bricks = c(Brick.file, Brick.file),
    x.coords = "chr19:5000000:10000000",
    y.coords = "chr19:5000001:10000000",
    FUN = Failsafe_log10,
    value.cap = 0.99,
    legend.title = "Log10 Hi-C signal",
    palette = "YlGnBu",
    distance = 30,
    width = 15,
    height = 4,
    rotate = TRUE,
    return.object=TRUE)

```

### Plotting TADs on Bipartite heatmaps

HiCBricks also allows the possibility to plot TADs on the Bipartite heatmaps
with categorical colours for each of the TAD calls. Although users may provide
more than one category per sample, they should be aware that when TADs overlap,
the TAD which is plotted at the end will always be the one that appears at the
top, while other overlapping TADs will be hidden at the bottom.

As an example we will prepare a set of TAD calls and store them in the Brick
object to compare them.

```{r}

Brick.file <- system.file("extdata",
    "test.hdf", package = "HiCBricks")

Chromosome <- "chr19"
di_windows <- c(5,10)
lookup_windows <- c(10, 20)
for (i in seq_along(di_windows)) {

    di_window <- di_windows[i]
    lookup_window <- lookup_windows[i]
    
    TAD_ranges <- Brick_local_score_differentiator(Brick = Brick.file,
        chrs = Chromosome,
        di.window = di_window,
        lookup.window = lookup_window,
        strict = TRUE,
        fill.gaps=TRUE,
        chunk.size = 500)
    
    Name <- paste("LSD",
        di_window,
        lookup_window,
        Chromosome,sep = "_")
    
    Brick_add_ranges(Brick = Path_to_cached_file, ranges = TAD_ranges,
        rangekey = Name)
}

```

To plot these TAD calls, they need to be formatted correctly before plotting.
This involves assigning categorical values to each of the TAD calls we want to
plot. We will assign two categorical variables, one will map the TADs to their
respective Hi-C map, whereas the other will map the TADs to their respective
category.

```{r}

Chromosome <- "chr19"
di_windows <- c(5,10)
lookup_windows <- c(10, 20)
TADs_list <- list()

for (i in seq_along(di_windows)) {

    di_window <- di_windows[i]
    lookup_window <- lookup_windows[i]
    
    Name <- paste("LSD",
        di_window,
        lookup_window,
        Chromosome,sep = "_")
    
    TAD_ranges <- Brick_get_ranges(Brick = Path_to_cached_file, 
        rangekey = Name)
    # Map TADs to their Hi-C maps
    TAD_ranges$group <- i
    # Map TADs to a specific categorical value for the colours
    TAD_ranges$colour.group <- paste("LSD", di_window, lookup_window, 
        sep = "_")
    TADs_list[[Name]] <- TAD_ranges
}

TADs_ranges <- do.call(c, unlist(TADs_list, use.names = FALSE))

```

As described in the manual, the two parameters, `group.col` and 
`tad.colour.col` are relevant towards assigning any TAD to its respective Hi-C
map or category, respectively. These two parameters take as input, the column
names corresponding to their respective columns in the `TADs_ranges` object. 
Meanwhile, `colours` and `colours.names` is the relevant parameter for the 
colours of the TAD boundaries. `colours` is a required parameter in case TAD 
boundaries are provided, whereas `colours.names` can be left empty in case the
user intends to provide `unique(TAD_ranges$colour.group)` as 
the `colour.names`.

```{r plot11, fig.cap = "A normal two sample heatmap with colours computed in log10 scale and capping these values to the 97th percentile, with TAD borders", fig.small = TRUE}

Brick.file <- system.file("extdata",
    "test.hdf", package = "HiCBricks")

Colours <- c("#B4436C", "#F78154")
Colour.names <- unique(TADs_ranges$colour.group)

Brick_vizart_plot_heatmap(File = file.path(tempdir(),
  "chr19-5MB-10MB-bipartite-colours-log10-valuecap-99-tads.pdf"),
    Bricks = c(Brick.file, Brick.file),
    x.coords = "chr19:5000001:10000000",
    y.coords = "chr19:5000001:10000000",
    FUN = Failsafe_log10,
    value.cap = 0.97,
    legend.title = "Log10 Hi-C signal",
    palette = "YlGnBu",
    tad.ranges = TADs_ranges,
    group.col = "group",
    tad.colour.col = "colour.group",
    colours = Colours,
    colours.names = Colour.names,
    distance = 30,
    width = 9,
    height = 11,
    return.object=TRUE)

```

```{r plot12, fig.cap = "A rotated two sample heatmap with colours computed in log10 scale and capping these values to the 97th percentile, with non-truncated TAD borders", fig.wide = TRUE}

Brick.file <- system.file("extdata",
    "test.hdf", package = "HiCBricks")

Colours <- c("#B4436C", "#F78154")
Colour.names <- unique(TADs_ranges$colour.group)

Brick_vizart_plot_heatmap(File = file.path(tempdir(),
  "chr19-5MB-10MB-bipartite-colours-log10-valuecap-99-rotate-tads.pdf"),
    Bricks = c(Brick.file, Brick.file),
    x.coords = "chr19:5000000:10000000",
    y.coords = "chr19:5000001:10000000",
    FUN = Failsafe_log10,
    value.cap = 0.97,
    legend.title = "Log10 Hi-C signal",
    palette = "YlGnBu",
    tad.ranges = TADs_ranges,
    group.col = "group",
    tad.colour.col = "colour.group",
    colours = Colours,
    colours.names = Colour.names,
    distance = 30,
    width = 15,
    height = 4,
    rotate = TRUE,
    return.object=TRUE)

```

Notice, that while creating rotated plots with TADs, if the parameter 
`cut.corners` is not set to TRUE, then the default behaviour is to plot
continuous lines. To truncate lines at the corners of TADs, users should
set this parameter as TRUE.


```{r plot13, fig.cap = "A rotated two sample heatmap with colours computed in log10 scale and capping these values to the 97th percentile, with truncated TAD borders", fig.wide = TRUE}

Brick.file <- system.file("extdata",
    "test.hdf", package = "HiCBricks")

Colours <- c("#B4436C", "#F78154")
Colour.names <- unique(TADs_ranges$colour.group)

Brick_vizart_plot_heatmap(File = file.path(tempdir(),
  "chr19-5MB-10MB-bipartite-colours-log10-valuecap-99-rotate-tads-2.pdf"),
    Bricks = c(Brick.file, Brick.file),
    x.coords = "chr19:5000000:10000000",
    y.coords = "chr19:5000001:10000000",
    FUN = Failsafe_log10,
    value.cap = 0.97,
    legend.title = "Log10 Hi-C signal",
    palette = "YlGnBu",
    tad.ranges = TADs_ranges,
    group.col = "group",
    tad.colour.col = "colour.group",
    colours = Colours,
    colours.names = Colour.names,
    distance = 30,
    width = 15,
    height = 4,
    cut.corners = TRUE,
    rotate = TRUE,
    return.object=TRUE)

```

### Making edits to additional plot elements

There are several problems in the above plots which are quickly noticeable.

- The TAD border lines are too thin and are not clearly. This problem can be
addressed by playing around with the `line.width` parameter.
- The legends are outside the bounds of the plotting area. We can make 
changes to the legend with a few parameter changes to the 
`legend.key.width` and `legend.key.height` parameters.

```{r plot14, fig.cap = "A rotated two sample heatmap with colours computed in log10 scale and capping these values to the 99th percentile.", fig.wide = TRUE}

Brick_vizart_plot_heatmap(File = file.path(tempdir(),
  "chr19-5MB-10MB-bipartite-final.pdf"),
    Bricks = c(Brick.file, Brick.file),
    x.coords = "chr19:5000000:10000000",
    y.coords = "chr19:5000001:10000000",
    FUN = Failsafe_log10,
    value.cap = 0.99,
    legend.title = "Log10 Hi-C signal",
    palette = "YlGnBu",
    tad.ranges = TADs_ranges,
    group.col = "group",
    tad.colour.col = "colour.group",
    colours = Colours,
    colours.names = Colour.names,
    distance = 30,
    width = 15,
    height = 4,
    legend.key.width = unit(10, "mm"), 
    legend.key.height = unit(5, "mm"),
    line.width = 1.2,
    cut.corners = TRUE,
    rotate = TRUE,
    return.object=TRUE)

```

### Modifying text elements in plots

There are several parameters which can be used to modify textual elements in 
plots. 

- It is possible to completely remove the x and y axis by setting the 
parameters `x.axis` and `y.axis` to FALSE. 
- The default x and y axis titles can be modified using the `x.axis.title` and 
`y.axis.title` parameter. 
- The plot title can be adjusted using the `title` parameter.
- The legend title can be adjusted using the `legend.title` parameter.
- Furthermore, users can also adjust the number of ticks that appear on the
x and y axis when these axis labels are present. The number of ticks can be
identified using the `x.axis.num.breaks` and `y.axis.num.breaks` parameters.

The parameters to modify text size in these individual elements are as follows
- `text.size` controls the font size across all plot elements, but is 
superseded by individual parameters.
- `x.axis.text.size` and `y.axis.text.size` control the text size on the x and
y axis.
- `legend.title.text.size` controls the font size of the legend title.
- `legend.text.size` controls the font size of individual legend elements.
- `title.size` controls the size of the plot title.


